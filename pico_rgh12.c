/**
 * PicoRGH12 - RGH 1.2 Glitcher for Xbox 360 on Raspberry Pi Pico
 * Custom implementation for Jasper/Tonasket motherboards.
 *
 * This firmware replicates the behavior of a CPLD-based glitch chip.
 * It synchronizes with the console's clock and counts POST transitions
 * before firing a glitch pulse.
 */

#include "pico/stdlib.h"
#include "hardware/pio.h"
#include "hardware/gpio.h"
#include "rgh12.pio.h" // This will be generated by pioasm

// --- Glitch Timing Parameters for Jasper ---
// These are STARTING points. Fine-tuning is almost certainly required.
#define POST_COUNT_TARGET 10   // Target POST code toggles before starting glitch
#define GLITCH_OFFSET 1000     // Delay (in external clock cycles) after POST count is met
#define GLITCH_WIDTH 100       // Width (in external clock cycles) of the glitch pulse

// --- GPIO Pin Definitions (as used in the .pio file) ---
#define POST_PIN 1
#define RESET_PIN 2
#define GLITCH_OUT_PIN 3
#define CLK_IN_PIN 0

int main() {
    // PIO setup
    PIO pio = pio0;
    uint offset = pio_add_program(pio, &rgh12_program);
    uint sm = pio_claim_unused_sm(pio, true);

    pio_sm_config c = rgh12_program_get_default_config(offset);

    // Configure PIO pins
    sm_config_set_in_pins(&c, POST_PIN);
    sm_config_set_jmp_pin(&c, RESET_PIN);
    sm_config_set_out_pins(&c, GLITCH_OUT_PIN, 1);
    sm_config_set_set_pins(&c, GLITCH_OUT_PIN, 1);

    // CRITICAL: Configure the PIO to use an external clock source on CLK_IN_PIN
    pio_gpio_init(pio, CLK_IN_PIN);
    gpio_set_dir(CLK_IN_PIN, GPIO_IN);
    sm_config_set_in_shiftdiv(&c, 1.0f);

    // Set pin directions for the State Machine
    pio_sm_set_consecutive_pindirs(pio, sm, POST_PIN, 1, false);      // POST is input
    pio_sm_set_consecutive_pindirs(pio, sm, RESET_PIN, 1, false);     // RESET is input
    pio_sm_set_consecutive_pindirs(pio, sm, GLITCH_OUT_PIN, 1, true); // GLITCH is output

    // Initialize and enable the PIO state machine
    pio_sm_init(pio, sm, offset, &c);
    pio_sm_set_enabled(pio, sm, true);

    // Push the timing configuration to the PIO's TX FIFO.
    // The PIO program will pull these values automatically.
    pio_sm_put_blocking(pio, sm, POST_COUNT_TARGET - 1);
    pio_sm_put_blocking(pio, sm, GLITCH_OFFSET - 1);
    pio_sm_put_blocking(pio, sm, GLITCH_WIDTH - 2);

    // The PIO handles all logic from here. The main CPU core has nothing left to do.
    while (true) {
        sleep_ms(2000);
    }

    return 0;
}
