/**
 * PicoRGH12 - RGH 1.2 Glitcher for Xbox 360 on Raspberry Pi Pico
 * Custom implementation for Jasper/Tonasket motherboards.
 *
 * This firmware replicates the behavior of a CPLD-based glitch chip.
 * It synchronizes with the console's clock and counts POST transitions
 * before firing a glitch pulse.
 *
 * --- Pico Wiring ---
 * GP0: CLK_IN (From Xbox 360 a 48MHz or 64MHz clock point)
 * GP1: POST_IN (POST_OUT1 from motherboard, e.g., FT2R2)
 * GP2: RESET_IN (From motherboard reset line)
 * GP3: GLITCH_OUT (To CPU_RST point on motherboard)
 * 3.3V -> 3.3V on Xbox 360
 * GND  -> GND on Xbox 360
 *
 * A 100 Ohm resistor on GLITCH_OUT is recommended.
 * A 220pF-270pF capacitor between GLITCH_OUT and GND may improve pulse shape.
 */

#include "pico/stdlib.h"
#include "hardware/pio.h"
#include "hardware/gpio.h"
#include "rgh12.pio.h" // This will be generated by pioasm

// --- Glitch Timing Parameters for Jasper ---
// These are STARTING points. Fine-tuning is almost certainly required.
// Refer to successful Jasper RGH 1.2 installs for common values.

// The number of POST bit toggles to wait for before starting the glitch sequence.
// For Jasper, a common value is around 0x0A (10).
#define POST_COUNT_TARGET 10

// The delay (in clock cycles) after the POST count is reached before firing the pulse.
// Typical range for Jasper: 500 - 1500
#define GLITCH_OFFSET 1000

// The width (in clock cycles) of the glitch pulse.
// Typical range for Jasper: 50 - 150
#define GLITCH_WIDTH 100


int main() {
    // Pin setup
    gpio_init(RESET_PIN);
    gpio_set_dir(RESET_PIN, GPIO_IN);

    // PIO setup
    PIO pio = pio0;
    uint offset = pio_add_program(pio, &rgh12_program);
    uint sm = pio_claim_unused_sm(pio, true);

    pio_sm_config c = rgh12_program_get_default_config(offset);

    // Configure PIO pins based on definitions in the .pio file
    sm_config_set_in_pins(&c, POST_PIN);    // Pin for counting POST toggles
    sm_config_set_jmp_pin(&c, RESET_PIN);   // Pin to check for reset state
    sm_config_set_out_pins(&c, GLITCH_OUT_PIN, 1);
    sm_config_set_set_pins(&c, GLITCH_OUT_PIN, 1);

    // --- CRITICAL: Configure the PIO clock ---
    // The state machine's clock will be driven by the CLK_IN_PIN.
    // This synchronizes the entire glitch timing to the Xbox 360.
    sm_config_set_clkdiv(&c, 1.0f); // Set divisor to 1, as clock is external
    pio_sm_set_consecutive_pindirs(pio, sm, POST_PIN, 1, false); // POST is input
    pio_sm_set_consecutive_pindirs(pio, sm, GLITCH_OUT_PIN, 1, true); // GLITCH is output

    // Initialize and enable the PIO state machine
    pio_sm_init(pio, sm, offset, &c);
    pio_sm_set_enabled(pio, sm, true);

    // --- Main Loop ---
    // The C code's only job is to push the configuration parameters
    // to the PIO. The PIO handles all the real-time glitch logic.
    // The PIO program is designed to re-arm itself on reset, so we only
    // need to configure it once.
    
    // Push configuration to the PIO's TX FIFO.
    // The PIO program will pull these in order.
    pio_sm_put_blocking(pio, sm, POST_COUNT_TARGET - 1); // PIO counts down to 0
    pio_sm_put_blocking(pio, sm, GLITCH_OFFSET - 1);
    pio_sm_put_blocking(pio, sm, GLITCH_WIDTH - 2);

    // The rest of the program can be empty. The PIO does all the work.
    while (true) {
        sleep_ms(1000); // Nothing to do here.
    }

    return 0;
}
